import logging
import asyncio
import datetime
import pandas as pd
import ta
import aiohttp
from tinkoff.invest import Client, CandleInterval
from tinkoff.invest.utils import now
from aiogram import Bot
import pytz

# ðŸ” Ð¢Ð¾ÐºÐµÐ½Ñ‹
TINKOFF_TOKEN = "t.d---"
TELEGRAM_TOKEN = ":-Io-"
CHAT_ID = -

# ðŸ“ˆ FIGI
FIGIS = {
    "TSLA": "BBG000N9MNX3",
    "YNDX": "BBG006L8G4H1",
    "VTBR": "BBG004730N88"
}

# â± Ð˜Ð½Ñ‚ÐµÑ€Ð²Ð°Ð»Ñ‹
INTERVALS = {
    "1m": CandleInterval.CANDLE_INTERVAL_1_MIN,
    "5m": CandleInterval.CANDLE_INTERVAL_5_MIN,
}

SLEEP_SECONDS = 60

# âš™ï¸ Ð›Ð¾Ð³Ð³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def get_candles_sync(client: Client, figi: str, interval: CandleInterval) -> pd.DataFrame:
    now_time = now()
    delta = datetime.timedelta(minutes=50 if interval == CandleInterval.CANDLE_INTERVAL_1_MIN else 250)
    from_time = now_time - delta
    to_time = now_time

    candles = client.market_data.get_candles(
        figi=figi,
        from_=from_time,
        to=to_time,
        interval=interval,
    ).candles

    if not candles:
        return pd.DataFrame()

    df = pd.DataFrame([{
        "time": c.time,
        "open": c.open.units + c.open.nano / 1e9,
        "close": c.close.units + c.close.nano / 1e9,
        "high": c.high.units + c.high.nano / 1e9,
        "low": c.low.units + c.low.nano / 1e9,
        "volume": c.volume,
    } for c in candles])

    return df


def analyze_macd_rsi(df: pd.DataFrame) -> dict | None:
    if len(df) < 35:
        return None

    df = df.copy()
    df.set_index("time", inplace=True)

    df["rsi"] = ta.momentum.RSIIndicator(close=df["close"], window=14).rsi()
    macd_calc = ta.trend.MACD(close=df["close"])
    df["macd"] = macd_calc.macd()
    df["macd_signal"] = macd_calc.macd_signal()
    df["macd_hist"] = macd_calc.macd_diff()

    latest_idx = df.index[-1]
    prev_idx = df.index[-2]

    signal = ""
    macd_cross = False
    if df["macd"][prev_idx] < df["macd_signal"][prev_idx] and df["macd"][latest_idx] > df["macd_signal"][latest_idx]:
        signal = "ðŸ’š *MACD Ð¿ÐµÑ€ÐµÑÐµÑ‡ÐµÐ½Ð¸Ðµ Ð²Ð²ÐµÑ€Ñ… (BUY)*"
        macd_cross = True
    elif df["macd"][prev_idx] > df["macd_signal"][prev_idx] and df["macd"][latest_idx] < df["macd_signal"][latest_idx]:
        signal = "â¤ï¸ *MACD Ð¿ÐµÑ€ÐµÑÐµÑ‡ÐµÐ½Ð¸Ðµ Ð²Ð½Ð¸Ð· (SELL)*"
        macd_cross = True

    latest_row = df.loc[latest_idx]
    ny_time = latest_idx.astimezone(pytz.timezone("America/New_York")).strftime("%Y-%m-%d %H:%M:%S")

    return {
        "signal": signal,
        "macd_cross": macd_cross,
        "rsi": round(latest_row["rsi"], 2),
        "macd": round(latest_row["macd"], 4),
        "macd_signal": round(latest_row["macd_signal"], 4),
        "macd_hist": round(latest_row["macd_hist"], 4),
        "close": round(latest_row["close"], 2),
        "high": round(latest_row["high"], 2),
        "low": round(latest_row["low"], 2),
        "time": ny_time
    }


async def main_loop():
    bot = Bot(token=TELEGRAM_TOKEN)
    async with aiohttp.ClientSession():
        with Client(TINKOFF_TOKEN) as client:
            while True:
                try:
                    for name, figi in FIGIS.items():
                        for interval_name, interval in INTERVALS.items():
                            df = await asyncio.to_thread(get_candles_sync, client, figi, interval)
                            if df.empty:
                                logger.warning(f"â›” ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¿Ð¾ {name} ({interval_name})")
                                continue

                            data = analyze_macd_rsi(df)
                            if not data:
                                continue

                            # Ð’ÑÐµÐ³Ð´Ð° ÑˆÐ»Ñ‘Ð¼ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ RSI Ð¸ MACD
                            text = (
                                f"ðŸ“Š *{name}* [{interval_name}]\n"
                                f"ðŸ•’ NY Time: {data['time']}\n"
                                f"ðŸ’° Ð¦ÐµÐ½Ð°: {data['close']}\n"
                                f"ðŸ”º High: {data['high']}, ðŸ”» Low: {data['low']}\n"
                                f"ðŸ“ˆ RSI: {data['rsi']}\n"
                                f"ðŸ“Š MACD: {data['macd']} | Signal: {data['macd_signal']} | Hist: {data['macd_hist']}"
                            )
                            await bot.send_message(chat_id=CHAT_ID, text=text, parse_mode="Markdown")

                            # ÐžÑ‚Ð´ÐµÐ»ÑŒÐ½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¸ Ð¿ÐµÑ€ÐµÑÐµÑ‡ÐµÐ½Ð¸Ð¸ MACD
                            if data["macd_cross"]:
                                await bot.send_message(chat_id=CHAT_ID, text=f"âš ï¸ *{name}* [{interval_name}] {data['signal']} Ð¿Ð¾ Ñ†ÐµÐ½Ðµ {data['close']}", parse_mode="Markdown")

                    logger.info("Ð¦Ð¸ÐºÐ» Ð·Ð°Ð²ÐµÑ€ÑˆÑ‘Ð½. Ð–Ð´Ñ‘Ð¼ ÑÐ»ÐµÐ´ÑƒÑŽÑ‰ÑƒÑŽ Ð¼Ð¸Ð½ÑƒÑ‚Ñƒ.")
                    await asyncio.sleep(SLEEP_SECONDS)

                except Exception as e:
                    logger.error(f"ÐžÑˆÐ¸Ð±ÐºÐ°: {e}")
                    await asyncio.sleep(SLEEP_SECONDS)


if __name__ == "__main__":
    logger.info("Ð—Ð°Ð¿ÑƒÑÐº")
    asyncio.run(main_loop())
