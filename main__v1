import logging
import asyncio
import datetime
import pandas as pd
import ta
import aiohttp
import pytz
from tinkoff.invest import Client, CandleInterval
from tinkoff.invest.utils import now
from aiogram import Bot

# üîê –¢–æ–∫–µ–Ω—ã
TINKOFF_TOKEN = ""
TELEGRAM_TOKEN = ""
CHAT_ID = -

# üîç –¢–∏–∫–µ—Ä—ã
TICKERS = ["AAPL", "MSFT", "TSLA", "GOOG", "AMZN", "NVDA", "META", "AMD", "INTC", "NFLX","BA", "DIS", "JPM", "WMT", "PEP", "KO", "CVX", "XOM", "BABA", "PFE","MRNA", "NKE", "T", "VZ", "CRM", "ADBE", "ORCL", "CSCO", "QCOM", "GE","UBER", "LYFT", "SQ", "PYPL", "SHOP", "SNAP", "ZM", "RIVN", "PLTR", "SOFI","F", "GM", "LCID", "TSM", "BIDU", "JD", "TLRY", "CVNA", "WBD", "EBAY, "DDD", "AMD", "APA", "AFRM", "AA", "BABA", "GOOGL", "AMZN", "AAL", "APP", "AAPL", "AMAT", "BA", "BYND", "BILI", "AI", "COF", "CAT", "CHGG", "CHWY", "CNK", "CLF", "CCL", "CSCO", "CLSK", "NET", "COIN", "COTY", "CPNG", "DHI", "DLO", "DDOG", "PLAY", "DVN", "APPS","DOCU", "DASH", "YDEX", "U", "TSLA"]

# –ò–Ω—Ç–µ—Ä–≤–∞–ª—ã
INTERVALS = {
    "1m": CandleInterval.CANDLE_INTERVAL_1_MIN,
    "5m": CandleInterval.CANDLE_INTERVAL_5_MIN,
}

SLEEP_SECONDS = 60
RSI_REPORT_INTERVAL_MINUTES = 60

# –õ–æ–≥–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def get_figi_by_ticker(client: Client, ticker: str) -> str | None:
    try:
        response = client.instruments.find_instrument(query=ticker)
        for instr in response.instruments:
            if instr.ticker == ticker:
                return instr.figi
    except Exception as e:
        logger.warning(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∏—Å–∫–µ –¥–ª—è {ticker}: {e}")
    return None


def get_candles_sync(client: Client, figi: str, interval: CandleInterval) -> pd.DataFrame:
    now_time = now()
    delta = datetime.timedelta(minutes=50 if interval == CandleInterval.CANDLE_INTERVAL_1_MIN else 250)
    candles = client.market_data.get_candles(
        figi=figi,
        from_=now_time - delta,
        to=now_time,
        interval=interval,
    ).candles

    if not candles:
        return pd.DataFrame()

    df = pd.DataFrame([{
        "time": c.time,
        "open": c.open.units + c.open.nano / 1e9,
        "close": c.close.units + c.close.nano / 1e9,
        "high": c.high.units + c.high.nano / 1e9,
        "low": c.low.units + c.low.nano / 1e9,
        "volume": c.volume,
    } for c in candles])

    return df


def analyze_macd_rsi(df: pd.DataFrame) -> dict | None:
    if len(df) < 35:
        return None

    df = df.copy()
    df.set_index("time", inplace=True)

    df["rsi"] = ta.momentum.RSIIndicator(close=df["close"], window=14).rsi()
    macd_calc = ta.trend.MACD(close=df["close"])
    df["macd"] = macd_calc.macd()
    df["macd_signal"] = macd_calc.macd_signal()
    df["macd_hist"] = macd_calc.macd_diff()

    latest = df.iloc[-1]
    previous = df.iloc[-2]
    ny_time = df.index[-1].astimezone(pytz.timezone("America/New_York")).strftime("%Y-%m-%d %H:%M:%S")

    signal = ""
    macd_cross = False
    if previous["macd"] < previous["macd_signal"] and latest["macd"] > latest["macd_signal"]:
        signal = "üíö *MACD –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –≤–≤–µ—Ä—Ö (BUY)*"
        macd_cross = True
    elif previous["macd"] > previous["macd_signal"] and latest["macd"] < latest["macd_signal"]:
        signal = "‚ù§Ô∏è *MACD –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –≤–Ω–∏–∑ (SELL)*"
        macd_cross = True

    return {
        "signal": signal,
        "macd_cross": macd_cross,
        "rsi": round(latest["rsi"], 2),
        "macd": round(latest["macd"], 4),
        "macd_signal": round(latest["macd_signal"], 4),
        "macd_hist": round(latest["macd_hist"], 4),
        "close": round(latest["close"], 2),
        "high": round(latest["high"], 2),
        "low": round(latest["low"], 2),
        "time": ny_time
    }

async def main_loop():
    bot = Bot(token=TELEGRAM_TOKEN)
    last_report_sent = False  # –§–ª–∞–≥ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –ø–æ–ª–Ω–æ–≥–æ –æ—Ç—á—ë—Ç–∞ —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ

    async with aiohttp.ClientSession():
        with Client(TINKOFF_TOKEN) as client:
            figis = {}
            for ticker in TICKERS:
                figi = get_figi_by_ticker(client, ticker)
                if figi:
                    figis[ticker] = figi
                else:
                    logger.warning(f"FIGI –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è {ticker}")

            while True:
                try:
                    ticker_texts = []

                    for ticker, figi in figis.items():
                        texts_per_ticker = []
                        for interval_name, interval in INTERVALS.items():
                            df = await asyncio.to_thread(get_candles_sync, client, figi, interval)
                            if df.empty:
                                logger.warning(f"–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ {ticker} ({interval_name})")
                                continue

                            result = analyze_macd_rsi(df)
                            if not result:
                                continue

                            # –ü—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ —Å–æ–±–∏—Ä–∞–µ–º –ø–æ–ª–Ω—ã–π –æ—Ç—á—ë—Ç
                            if not last_report_sent:
                                part_text = (
                                    f"üìä [{interval_name}]\n"
                                    f"üïí NY Time: {result['time']}\n"
                                    f"üí∞ –¶–µ–Ω–∞: {result['close']}\n"
                                    f"üî∫ High: {result['high']}, üîª Low: {result['low']}\n"
                                    f"üìà RSI: {result['rsi']}\n"
                                    f"üìä MACD: {result['macd']} | Signal: {result['macd_signal']} | Hist: {result['macd_hist']}\n"
                                )
                                texts_per_ticker.append(part_text)

                            # –ö–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ —Å–∏–≥–Ω–∞–ª—ã –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π MACD –ø—Ä–∏ —É—Å–ª–æ–≤–∏–∏ RSI
                            if last_report_sent and result["macd_cross"]:
                                if (result["signal"].find("BUY") != -1 and result["rsi"] < 40) or \
                                   (result["signal"].find("SELL") != -1 and result["rsi"] > 60):
                                    alert_text = f"‚ö†Ô∏è *{ticker} ({figi})* [{interval_name}] {result['signal']} –ø–æ —Ü–µ–Ω–µ {result['close']} —Å RSI={result['rsi']}"
                                    await bot.send_message(chat_id=CHAT_ID, text=alert_text, parse_mode="Markdown")

                        if texts_per_ticker:
                            ticker_texts.append(f"*{ticker} ({figi})*\n\n" + "\n".join(texts_per_ticker))

                    # –ï—Å–ª–∏ –æ—Ç—á—ë—Ç –Ω–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω ‚Äî –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –µ–≥–æ –æ–¥–Ω–∏–º –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
                    if not last_report_sent:
                        MAX_MSG_LENGTH = 4000
                        GROUP_SIZE = 5
                        for i in range(0, len(ticker_texts), GROUP_SIZE):
                            chunk = ticker_texts[i:i + GROUP_SIZE]
                            message_text = "\n\n".join(chunk)

                            if len(message_text) > MAX_MSG_LENGTH:
                                message_text = message_text[:MAX_MSG_LENGTH - 20] + "\n‚Ä¶ (—Å–æ–æ–±—â–µ–Ω–∏–µ –æ–±—Ä–µ–∑–∞–Ω–æ)"

                            await bot.send_message(chat_id=CHAT_ID, text=message_text, parse_mode="Markdown")
                        last_report_sent = True

                    logger.info("–¶–∏–∫–ª –∑–∞–≤–µ—Ä—à—ë–Ω. –ñ–¥—ë–º —Å–ª–µ–¥—É—é—â—É—é –º–∏–Ω—É—Ç—É.")
                    await asyncio.sleep(SLEEP_SECONDS)

                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞: {e}")
                    await asyncio.sleep(SLEEP_SECONDS)


if __name__ == "__main__":
    logger.info("–ó–∞–ø—É—Å–∫")
    asyncio.run(main_loop())
