import logging
import asyncio
import datetime
import pandas as pd
import ta
import aiohttp
from tinkoff.invest import Client, CandleInterval
from tinkoff.invest.utils import now
from aiogram import Bot
import pytz

# 🔐 Токены
TINKOFF_TOKEN = "t.d---"
TELEGRAM_TOKEN = ":-Io-"
CHAT_ID = -

# 📈 FIGI
FIGIS = {
    "TSLA": "BBG000N9MNX3",
    "YNDX": "BBG006L8G4H1",
    "VTBR": "BBG004730N88"
}

# ⏱ Интервалы
INTERVALS = {
    "1m": CandleInterval.CANDLE_INTERVAL_1_MIN,
    "5m": CandleInterval.CANDLE_INTERVAL_5_MIN,
}

SLEEP_SECONDS = 60

# ⚙️ Логгирование
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def get_candles_sync(client: Client, figi: str, interval: CandleInterval) -> pd.DataFrame:
    now_time = now()
    delta = datetime.timedelta(minutes=50 if interval == CandleInterval.CANDLE_INTERVAL_1_MIN else 250)
    from_time = now_time - delta
    to_time = now_time

    candles = client.market_data.get_candles(
        figi=figi,
        from_=from_time,
        to=to_time,
        interval=interval,
    ).candles

    if not candles:
        return pd.DataFrame()

    df = pd.DataFrame([{
        "time": c.time,
        "open": c.open.units + c.open.nano / 1e9,
        "close": c.close.units + c.close.nano / 1e9,
        "high": c.high.units + c.high.nano / 1e9,
        "low": c.low.units + c.low.nano / 1e9,
        "volume": c.volume,
    } for c in candles])

    return df


def analyze_macd_rsi(df: pd.DataFrame) -> dict | None:
    if len(df) < 35:
        return None

    df = df.copy()
    df.set_index("time", inplace=True)

    df["rsi"] = ta.momentum.RSIIndicator(close=df["close"], window=14).rsi()
    macd_calc = ta.trend.MACD(close=df["close"])
    df["macd"] = macd_calc.macd()
    df["macd_signal"] = macd_calc.macd_signal()
    df["macd_hist"] = macd_calc.macd_diff()

    latest_idx = df.index[-1]
    prev_idx = df.index[-2]

    signal = ""
    macd_cross = False
    if df["macd"][prev_idx] < df["macd_signal"][prev_idx] and df["macd"][latest_idx] > df["macd_signal"][latest_idx]:
        signal = "💚 *MACD пересечение вверх (BUY)*"
        macd_cross = True
    elif df["macd"][prev_idx] > df["macd_signal"][prev_idx] and df["macd"][latest_idx] < df["macd_signal"][latest_idx]:
        signal = "❤️ *MACD пересечение вниз (SELL)*"
        macd_cross = True

    latest_row = df.loc[latest_idx]
    ny_time = latest_idx.astimezone(pytz.timezone("America/New_York")).strftime("%Y-%m-%d %H:%M:%S")

    return {
        "signal": signal,
        "macd_cross": macd_cross,
        "rsi": round(latest_row["rsi"], 2),
        "macd": round(latest_row["macd"], 4),
        "macd_signal": round(latest_row["macd_signal"], 4),
        "macd_hist": round(latest_row["macd_hist"], 4),
        "close": round(latest_row["close"], 2),
        "high": round(latest_row["high"], 2),
        "low": round(latest_row["low"], 2),
        "time": ny_time
    }


async def main_loop():
    bot = Bot(token=TELEGRAM_TOKEN)
    async with aiohttp.ClientSession():
        with Client(TINKOFF_TOKEN) as client:
            while True:
                try:
                    for name, figi in FIGIS.items():
                        for interval_name, interval in INTERVALS.items():
                            df = await asyncio.to_thread(get_candles_sync, client, figi, interval)
                            if df.empty:
                                logger.warning(f"⛔ Нет данных по {name} ({interval_name})")
                                continue

                            data = analyze_macd_rsi(df)
                            if not data:
                                continue

                            # Всегда шлём параметры RSI и MACD
                            text = (
                                f"📊 *{name}* [{interval_name}]\n"
                                f"🕒 NY Time: {data['time']}\n"
                                f"💰 Цена: {data['close']}\n"
                                f"🔺 High: {data['high']}, 🔻 Low: {data['low']}\n"
                                f"📈 RSI: {data['rsi']}\n"
                                f"📊 MACD: {data['macd']} | Signal: {data['macd_signal']} | Hist: {data['macd_hist']}"
                            )
                            await bot.send_message(chat_id=CHAT_ID, text=text, parse_mode="Markdown")

                            # Отдельное сообщение при пересечении MACD
                            if data["macd_cross"]:
                                await bot.send_message(chat_id=CHAT_ID, text=f"⚠️ *{name}* [{interval_name}] {data['signal']} по цене {data['close']}", parse_mode="Markdown")

                    logger.info("Цикл завершён. Ждём следующую минуту.")
                    await asyncio.sleep(SLEEP_SECONDS)

                except Exception as e:
                    logger.error(f"Ошибка: {e}")
                    await asyncio.sleep(SLEEP_SECONDS)


if __name__ == "__main__":
    logger.info("Запуск")
    asyncio.run(main_loop())
